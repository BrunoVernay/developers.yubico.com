= Signing with WebAuthn

While WebAuthn was designed primarily for authentication, the framework can be extended to support signing with keypairs generated on authenticators without requiring custom clients for end users.

== Overview
During a standard WebAuthn interaction, a WebAuthn authenticator creates a unique asymmetric keypair with a relying party at registration, with the private key residing only on the authenticator and the public key sent back. As part of the registration event, a challenge from the relying party which includes a random string is signed with the unqiue keypair and returned. In short, the registration event consists of a cryptographic signing process with the public key returned. Replacing the randomly generated challenge with a hash of a file to be signed allows this signtature flow to be applied to actual documentation, with the public key also avalible for verification after the fact.

The main advantages to this flow is it allows for any cryptographic algorithm supported by the WebAuthn framework to be used, and can leverage the existing WebAuthn support in browsers or local APIs without the need to apply code changes. All of the modifications required would be limited to the WebAuthn libraries/servers owned by the relying party, permitting a service to impliment arbitrary file signing without requiring significant user commitment.

== High-Level Architecture
This section will discuss at a high level the architecture neccessary for adapting a WebAuthn flow for file signing. The actual implimentation will depend on the environment, WebAuthn server or library and the WebAuthn client (brower or local) in use, and is outside of the scope of this document.

The method for leveraging WebAuthn for signture operations on arbitrary files is built around the FIDO Signature Creation flow, comprised of the link:https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred[MakeCredential] and link:https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion[GetAssertion] operations.

In the link:https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred[MakeCredential] operation, the challenge is defined as a random string. This can be replaced with a hash of the document to be signed, creating an associated with the data to be signed and the document in question. The method in which this hash is generated should be determined by the capabilities of the environment and security requirements under which the application is run. Other fields in the MakeCredential can be provided with other identifing information or left to default values. However, it is important to note the orginID should match the endpoint the user is provided to access the signing service, as is the case in a standard WebAuthn service.

Further, in the link:https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred[MakeCredential] operation, the algorithm for the keypair must be defined. The WebAuthn framework defines the algorithm to be used when the authenticatior generates the keypair via the identifier registered in the IANA COSE Algorithm Registry, as detailed in the link:https://www.w3.org/TR/webauthn-2/#sctn-alg-identifier[Cryptographic Algorithm Identifier] section. For example, EdDSA is defined as (-8). The requirements for detailing the algorithm to be used is well defined in the WebAuthn specification, however not all authenticators support all algorithms. It is recommended to include logic to capture the case where a user attempts to use an algorithm not supported by their authenticator.

With the challenge replaced with a hash of the data to be signed, and the algorthm defined, the link:https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion[GetAssertion] operation is used to actually sign the data. No modifications are required to this operation to support the signature, but both the link:https://www.w3.org/TR/webauthn-1/#dictdef-collectedclientdata[client data] and link:https://www.w3.org/TR/webauthn-1/#sec-authenticator-data[authenticator data] will need to be recorded along with the returned signature. This is because the signature returned by WebAuthn is for an object comprising both the client data (including the hash string) and authenticator data, and both sets of data will be required to validate the signature in the future. To assist with the, the PublicKeyCredential returned will include the client data (as a JSON object), the authenticator data and the signtaure. Simply archiving everything returned will allow for ease of signature validation. In a pinch, the client data does not absolutely need to be retained as it can be reconstucted as long as the domain is known and the relying party remains operational, but for ease of access and export, there are benefits for simply storing it.

The signature can be verified with the public key also returned by the WebAuthn event. With a validated signature, the hash within the signed data can be compared with a hash generated by the signed file for authenticity. Should a user need to demonstrate the authenticity of their WebAuthn authenticator, a simple WebAuthn authentication event using the identity registered may be used to verify their authenticator.

